use crate::keyboard::LedColor;
use log::debug;
use num::{FromPrimitive, ToPrimitive};

pub struct Messages {}

impl Messages {
    /// Message to read the key mappings from the macropad
    ///
    /// # Arguments
    /// `keys` - The number of keys on the macropad
    /// `encoders` - The number of rotary encoders on the macropad
    /// `layers` - The layer to read the configuration for
    ///
    pub fn read_config(keys: u8, encoders: u8, layer: u8) -> Vec<u8> {
        vec![
            0x03, 0xfa, keys, encoders, layer, 0x02, 0xe0, 0xcb, 0x80, 0x00, 0xa0, 0xcc, 0x80,
            0x00, 0x7c, 0xf2, 0x02, 0x69, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x00, 0x2c, 0x02, 0xa0,
            0xcc, 0x80, 0x00, 0xe8, 0x00, 0x00, 0x00, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x90, 0xcc, 0x80, 0x00, 0x20, 0xcd, 0x80, 0x00, 0xc0, 0x84, 0x26, 0x02, 0xa0,
            0x62, 0x2f, 0x02, 0xc0, 0xcc, 0x80, 0x00, 0xc7, 0xb6, 0xc2,
        ]
    }

    /// Message to read what type of macropad is connected
    ///
    pub fn device_type() -> Vec<u8> {
        vec![
            0x03, 0xfb, 0xfb, 0xfb, 0x1f, 0x02, 0x3c, 0xd0, 0x80, 0x00, 0xec, 0xcf, 0x80, 0x00,
            0xcc, 0xd2, 0x9b, 0x00, 0xf0, 0xcf, 0x80, 0x00, 0x3c, 0xd0, 0x80, 0x00, 0x56, 0x83,
            0xd2, 0x7b, 0xd0, 0x0d, 0x48, 0x00, 0x0c, 0xd0, 0x80, 0x00, 0xa8, 0x3d, 0x34, 0x02,
            0x48, 0xd0, 0x80, 0x00, 0x70, 0xf5, 0x1e, 0x62, 0x98, 0xda, 0x11, 0x62, 0x0c, 0x80,
            0x00, 0x00, 0x00, 0x82, 0x26, 0x02, 0xff, 0xff, 0xff,
        ]
    }

    /// Message sent to device when a it is done being prgrammed. This will cause the device
    /// to store they key in nvram
    ///
    pub fn end_program() -> Vec<u8> {
        vec![
            0x03, 0xfd, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]
    }

    /// Programs the LEDs
    ///
    /// # Arguments
    /// `mode` - The mode to be set for the LEDs
    /// `keys` - The color to be set for the LEDs
    ///
    pub fn program_led(mode: u8, color: LedColor) -> Vec<u8> {
        let mut m_c = <LedColor as ToPrimitive>::to_u8(&color).unwrap();
        m_c |= mode;
        debug!("mode and code:0x{:02}", m_c);
        vec![
            0x03, 0xfe, 0xb0, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, m_c, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]
    }

    /*
    pub fn build_key_msg(key: KeyChord, key_pos: u8, layer: u8, delay: u16) -> Result<Vec<u8>> {
        // check layer
        if layer == 0 || layer > 3 {
            return Err(anyhow!("Invalid layer. Must be between 1 and 3 inclusive"));
        }

        // ensure we have a valid keychord
        if key.keys.len() > consts::MAX_KEYCHORD {
            return Err(anyhow!(
                "Maximum keys for a keypress exceeded! Maximum is {}",
                consts::MAX_KEYCHORD
            ));
        }
        let num_keys = key.keys.len() as u8;

        if delay > 6000 {
            return Err(anyhow!("Maximum delay is {}ms!", consts::MAX_DELAY));
        }
        let delay_b = delay.to_le_bytes();

        let mut msg = vec![
            0x03, 0xfd, key_pos, layer, 0x01, delay_b[0], delay_b[1], 0x00, 0x00, 0x00, num_keys,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        // set keys
        let mut index = 11;
        debug!("{:?}", key.keys);
        for i in key.keys {
            debug!("i: {:?}  index: {index}", i);
            let km = Self::key_mapping(i).to_le_bytes();
            msg[index] = km[0];
            msg[index + 1] = km[1];
            index += 2;
        }

        Ok(msg)
    }

    fn key_mapping(key: Key) -> u16 {
        let mut first = 0u8;
        if key.modifiers.is_some() {
            first |= key.modifiers.expect("modifier expected").as_u8();
        }

        u16::from_le_bytes([first, key.wkc.unwrap() as u8])
    }
    */
}
